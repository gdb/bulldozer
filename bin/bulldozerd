#!/usr/bin/env ruby
require 'optparse'

require 'eventmachine'
require 'bulldozer'

module Bulldozer
  class Bulldozerd
    def initialize(basedir)
      @basedir = basedir
      @workers = {}
    end

    def prepare_worker_pool(job)
      repo_spec = job['repo']
      entry_point = job['entry_point']

      # TODO: better hash key?
      unless @workers[repo_spec]
        repo = Bulldozer::Repo.from_spec(repo_spec, @basedir)
        repo.ensure_checkout

        workers = Bulldozer::WorkerPool.new(repo, entry_point)
        workers.spawn

        @workers[repo_spec] = workers
      end

      @workers[repo_spec]
    end

    def run
      Bulldozer::RabbitMQ.job_queue.subscribe(:ack => true) do |headers, payload|
        # TODO: report failed jobs in some way
        job = MessagePack.unpack(payload)
        Bulldozer.log.debug("Bulldozerd received a new job: #{job.inspect}")

        worker_pool = prepare_worker_pool(job)
        worker_pool.transmit(job)

        Bulldozer::RabbitMQ.ack(headers.delivery_tag)
      end
    end
  end
end

def main
  options = {}
  optparse = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options]"

    opts.on('-v', '--verbosity', 'Verbosity of debugging output') do
      $log.level -= 1
    end

    opts.on('-h', '--help', 'Display this message') do
      puts opts
      exit(1)
    end
  end
  optparse.parse!

  if ARGV.length != 0
    puts optparse
    return 1
  end

  EM.run do
    Bulldozer::RabbitMQ.connect_async

    runner = Bulldozer::Bulldozerd.new('/tmp/bulldozer')
    runner.run
  end
  return 0
end

if $0 == __FILE__
  ret = main
  begin
    exit(ret)
  rescue TypeError
    exit(0)
  end
end
